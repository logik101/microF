import React, { createContext, useState, useContext, ReactNode, useEffect } from 'react';
import { BlogArticle, GitHubConfig } from '../types';
import { blogArticles as initialArticles } from '../constants/blogData';

interface BlogContextType {
  articles: BlogArticle[];
  addArticle: (article: BlogArticle) => void;
  updateArticle: (article: BlogArticle) => void;
  deleteArticle: (id: number) => void;
  toggleHideArticle: (id: number) => void;
  
  // Github Config & Sync
  githubConfig: GitHubConfig | null;
  configureGithub: (config: GitHubConfig) => void;
  triggerGithubSync: (articlesToSave?: BlogArticle[]) => Promise<void>;
  syncStatus: { type: 'idle' | 'loading' | 'success' | 'error', message: string };
  resetSyncStatus: () => void;
}

const BlogContext = createContext<BlogContextType | undefined>(undefined);

const STORAGE_KEY = 'microforms_blog_posts';
const GITHUB_CONFIG_KEY = 'microforms_github_config';

// HARDCODED CONFIGURATION
// Switched to .json for easier runtime fetching
const PERMANENT_GITHUB_CONFIG: GitHubConfig = {
    owner: 'logik101',
    repo: 'microF',
    path: 'src/constants/blogData.json', 
    token: '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'
};

export const BlogProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  // Initialize articles state
  // Priority: 1. LocalStorage (instant load) 2. Initial Bundled Data
  const [articles, setArticles] = useState<BlogArticle[]>(() => {
    try {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        return JSON.parse(saved);
      }
    } catch (error) {
      console.error("Failed to load blog posts from storage", error);
    }
    return initialArticles;
  });

  const [githubConfig, setGithubConfig] = useState<GitHubConfig | null>(PERMANENT_GITHUB_CONFIG);
  const [syncStatus, setSyncStatus] = useState<{ type: 'idle' | 'loading' | 'success' | 'error', message: string }>({ type: 'idle', message: '' });

  // Load LIVE data from GitHub on mount
  useEffect(() => {
    const fetchLiveArticles = async () => {
        try {
            const { owner, repo, path } = PERMANENT_GITHUB_CONFIG;
            // Fetch raw JSON directly from GitHub main branch
            // This bypasses the build delay
            const url = `https://raw.githubusercontent.com/${owner}/${repo}/main/${path}`;
            const res = await fetch(url);
            
            if (res.ok) {
                const remoteArticles: BlogArticle[] = await res.json();
                
                // Logic: Remote data is the "Source of Truth" for public posts.
                // We update our state to match remote, but we might want to preserve local drafts if we are admin?
                // For simplicity and consistency: The remote overrides local, ensuring everyone sees the same thing.
                setArticles(remoteArticles);
                
                // Update local storage to match the latest live data
                localStorage.setItem(STORAGE_KEY, JSON.stringify(remoteArticles));
            }
        } catch (error) {
            console.warn("Could not fetch live blog data from GitHub, using local fallback.", error);
        }
    };

    fetchLiveArticles();
  }, []);

  // Save to LocalStorage whenever articles change
  useEffect(() => {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(articles));
    } catch (error) {
      console.error("Failed to save blog posts to storage", error);
    }
  }, [articles]);

  const addArticle = (article: BlogArticle) => {
    setArticles((prev) => [article, ...prev]);
  };

  const updateArticle = (updatedArticle: BlogArticle) => {
    setArticles((prev) => 
        prev.map((article) => article.id === updatedArticle.id ? updatedArticle : article)
    );
  };

  const deleteArticle = (id: number) => {
    setArticles((prev) => prev.filter((article) => article.id !== id));
  };

  const toggleHideArticle = (id: number) => {
      setArticles((prev) => 
        prev.map((article) => 
            article.id === id ? { ...article, isHidden: !article.isHidden } : article
        )
      );
  };

  const configureGithub = (config: GitHubConfig) => {
      setGithubConfig(config);
      localStorage.setItem(GITHUB_CONFIG_KEY, JSON.stringify(config));
  };

  const resetSyncStatus = () => {
    setSyncStatus({ type: 'idle', message: '' });
  };

  // Generate pure JSON content
  const generateFileContent = (data: BlogArticle[]) => {
    return JSON.stringify(data, null, 4);
  };

  const triggerGithubSync = async (articlesToSave?: BlogArticle[]) => {
      if (!githubConfig) {
          console.log("No GitHub config found. Skipping sync.");
          return;
      }

      const dataToSave = articlesToSave || articles;
      setSyncStatus({ type: 'loading', message: 'Saving changes...' });

      try {
        const { owner, repo, path, token } = githubConfig;
        const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;
        const headers = {
            'Authorization': `token ${token}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json',
        };

        // 1. Get current file SHA (to update existing file)
        let sha = undefined;
        const getResponse = await fetch(apiUrl, { headers });
        
        if (getResponse.ok) {
            const getData = await getResponse.json();
            sha = getData.sha;
        } else if (getResponse.status === 404) {
            console.log("File not found on remote, creating new file...");
        } else {
            // If it fails (e.g. repo empty), we try to create anyway
            console.warn("Could not get file info, attempting create...");
        }

        // 2. Prepare content
        const content = generateFileContent(dataToSave);
        // UTF-8 safe base64 encoding
        const base64Content = btoa(unescape(encodeURIComponent(content)));

        // 3. Update (or Create) file
        const body = JSON.stringify({
            message: 'Auto-update via MicroFormS Dashboard',
            content: base64Content,
            sha: sha, 
        });

        const putResponse = await fetch(apiUrl, {
            method: 'PUT',
            headers,
            body,
        });

        if (!putResponse.ok) {
             const errText = await putResponse.text();
             throw new Error(`Failed to save file. ${errText}`);
        }

        setSyncStatus({ type: 'success', message: 'Changes saved successfully!' });
        
        setTimeout(() => {
            setSyncStatus({ type: 'idle', message: '' });
        }, 5000);

      } catch (error: any) {
          console.error(error);
          setSyncStatus({ type: 'error', message: 'Error saving changes.' });
      }
  };

  return (
    <BlogContext.Provider value={{ 
        articles, 
        addArticle, 
        updateArticle, 
        deleteArticle, 
        toggleHideArticle,
        githubConfig,
        configureGithub,
        triggerGithubSync,
        syncStatus,
        resetSyncStatus
    }}>
      {children}
    </BlogContext.Provider>
  );
};

export const useBlog = (): BlogContextType => {
  const context = useContext(BlogContext);
  if (!context) {
    throw new Error('useBlog must be used within a BlogProvider');
  }
  return context;
};
